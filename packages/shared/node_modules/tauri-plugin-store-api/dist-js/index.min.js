// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
/** @ignore */
function uid() {
    return window.crypto.getRandomValues(new Uint32Array(1))[0];
}
/**
 * Transforms a callback function to a string identifier that can be passed to the backend.
 * The backend uses the identifier to `eval()` the callback.
 *
 * @return A unique identifier associated with the callback function.
 *
 * @since 1.0.0
 */
function transformCallback(callback, once = false) {
    const identifier = uid();
    const prop = `_${identifier}`;
    Object.defineProperty(window, prop, {
        value: (result) => {
            if (once) {
                Reflect.deleteProperty(window, prop);
            }
            return callback?.(result);
        },
        writable: false,
        configurable: true
    });
    return identifier;
}
/**
 * Sends a message to the backend.
 * @example
 * ```typescript
 * import { invoke } from '@tauri-apps/api/tauri';
 * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });
 * ```
 *
 * @param cmd The command name.
 * @param args The optional arguments to pass to the command.
 * @return A promise resolving or rejecting to the backend response.
 *
 * @since 1.0.0
 */
async function invoke(cmd, args = {}) {
    return new Promise((resolve, reject) => {
        const callback = transformCallback((e) => {
            resolve(e);
            Reflect.deleteProperty(window, `_${error}`);
        }, true);
        const error = transformCallback((e) => {
            reject(e);
            Reflect.deleteProperty(window, `_${callback}`);
        }, true);
        window.__TAURI_IPC__({
            cmd,
            callback,
            error,
            ...args
        });
    });
}

// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
/** @ignore */
async function invokeTauriCommand(command) {
    return invoke('tauri', command);
}

// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
/**
 * Unregister the event listener associated with the given name and id.
 *
 * @ignore
 * @param event The event name
 * @param eventId Event identifier
 * @returns
 */
async function _unlisten(event, eventId) {
    return invokeTauriCommand({
        __tauriModule: 'Event',
        message: {
            cmd: 'unlisten',
            event,
            eventId
        }
    });
}
/**
 * Listen to an event from the backend.
 *
 * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.
 * @param handler Event handler callback.
 * @return A promise resolving to a function to unlisten to the event.
 */
async function listen$1(event, windowLabel, handler) {
    return invokeTauriCommand({
        __tauriModule: 'Event',
        message: {
            cmd: 'listen',
            event,
            windowLabel,
            handler: transformCallback(handler)
        }
    }).then((eventId) => {
        return async () => _unlisten(event, eventId);
    });
}

// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
/**
 * The event system allows you to emit events to the backend and listen to events from it.
 *
 * This package is also accessible with `window.__TAURI__.event` when [`build.withGlobalTauri`](https://tauri.app/v1/api/config/#buildconfig.withglobaltauri) in `tauri.conf.json` is set to `true`.
 * @module
 */
/**
 * @since 1.1.0
 */
var TauriEvent;
(function (TauriEvent) {
    TauriEvent["WINDOW_RESIZED"] = "tauri://resize";
    TauriEvent["WINDOW_MOVED"] = "tauri://move";
    TauriEvent["WINDOW_CLOSE_REQUESTED"] = "tauri://close-requested";
    TauriEvent["WINDOW_CREATED"] = "tauri://window-created";
    TauriEvent["WINDOW_DESTROYED"] = "tauri://destroyed";
    TauriEvent["WINDOW_FOCUS"] = "tauri://focus";
    TauriEvent["WINDOW_BLUR"] = "tauri://blur";
    TauriEvent["WINDOW_SCALE_FACTOR_CHANGED"] = "tauri://scale-change";
    TauriEvent["WINDOW_THEME_CHANGED"] = "tauri://theme-changed";
    TauriEvent["WINDOW_FILE_DROP"] = "tauri://file-drop";
    TauriEvent["WINDOW_FILE_DROP_HOVER"] = "tauri://file-drop-hover";
    TauriEvent["WINDOW_FILE_DROP_CANCELLED"] = "tauri://file-drop-cancelled";
    TauriEvent["MENU"] = "tauri://menu";
    TauriEvent["CHECK_UPDATE"] = "tauri://update";
    TauriEvent["UPDATE_AVAILABLE"] = "tauri://update-available";
    TauriEvent["INSTALL_UPDATE"] = "tauri://update-install";
    TauriEvent["STATUS_UPDATE"] = "tauri://update-status";
    TauriEvent["DOWNLOAD_PROGRESS"] = "tauri://update-download-progress";
})(TauriEvent || (TauriEvent = {}));
/**
 * Listen to an event. The event can be either global or window-specific.
 * See {@link Event.windowLabel} to check the event source.
 *
 * @example
 * ```typescript
 * import { listen } from '@tauri-apps/api/event';
 * const unlisten = await listen<string>('error', (event) => {
 *   console.log(`Got error in window ${event.windowLabel}, payload: ${event.payload}`);
 * });
 *
 * // you need to call unlisten if your handler goes out of scope e.g. the component is unmounted
 * unlisten();
 * ```
 *
 * @param event Event name. Must include only alphanumeric characters, `-`, `/`, `:` and `_`.
 * @param handler Event handler callback.
 * @returns A promise resolving to a function to unlisten to the event.
 * Note that removing the listener is required if your listener goes out of scope e.g. the component is unmounted.
 *
 * @since 1.0.0
 */
async function listen(event, handler) {
    return listen$1(event, null, handler);
}

// Copyright 2021 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
/**
 * A key-value store persisted by the backend layer.
 */
class Store {
    constructor(path) {
        this.path = path;
    }
    /**
     * Inserts a key-value pair into the store.
     *
     * @param key
     * @param value
     * @returns
     */
    async set(key, value) {
        return await invoke("plugin:store|set", {
            path: this.path,
            key,
            value,
        });
    }
    /**
     * Returns the value for the given `key` or `null` the key does not exist.
     *
     * @param key
     * @returns
     */
    async get(key) {
        return await invoke("plugin:store|get", {
            path: this.path,
            key,
        });
    }
    /**
     * Returns `true` if the given `key` exists in the store.
     *
     * @param key
     * @returns
     */
    async has(key) {
        return await invoke("plugin:store|has", {
            path: this.path,
            key,
        });
    }
    /**
     * Removes a key-value pair from the store.
     *
     * @param key
     * @returns
     */
    async delete(key) {
        return await invoke("plugin:store|delete", {
            path: this.path,
            key,
        });
    }
    /**
     * Clears the store, removing all key-value pairs.
     *
     * Note: To clear the storage and reset it to it's `default` value, use `reset` instead.
     * @returns
     */
    async clear() {
        return await invoke("plugin:store|clear", {
            path: this.path,
        });
    }
    /**
     * Resets the store to it's `default` value.
     *
     * If no default value has been set, this method behaves identical to `clear`.
     * @returns
     */
    async reset() {
        return await invoke("plugin:store|reset", {
            path: this.path,
        });
    }
    /**
     * Returns a list of all key in the store.
     *
     * @returns
     */
    async keys() {
        return await invoke("plugin:store|keys", {
            path: this.path,
        });
    }
    /**
     * Returns a list of all values in the store.
     *
     * @returns
     */
    async values() {
        return await invoke("plugin:store|values", {
            path: this.path,
        });
    }
    /**
     * Returns a list of all entries in the store.
     *
     * @returns
     */
    async entries() {
        return await invoke("plugin:store|entries", {
            path: this.path,
        });
    }
    /**
     * Returns the number of key-value pairs in the store.
     *
     * @returns
     */
    async length() {
        return await invoke("plugin:store|length", {
            path: this.path,
        });
    }
    /**
     * Attempts to load the on-disk state at the stores `path` into memory.
     *
     * This method is useful if the on-disk state was edited by the user and you want to synchronize the changes.
     *
     * Note: This method does not emit change events.
     * @returns
     */
    async load() {
        return await invoke("plugin:store|load", {
            path: this.path,
        });
    }
    /**
     * Saves the store to disk at the stores `path`.
     *
     * As the store is only persisted to disk before the apps exit, changes might be lost in a crash.
     * This method lets you persist the store to disk whenever you deem necessary.
     * @returns
     */
    async save() {
        return await invoke("plugin:store|save", {
            path: this.path,
        });
    }
    /**
     * Listen to changes on a store key.
     * @param key
     * @param cb
     * @returns A promise resolving to a function to unlisten to the event.
     */
    async onKeyChange(key, cb) {
        return await listen("store://change", (event) => {
            if (event.payload.path === this.path && event.payload.key === key) {
                cb(event.payload.value);
            }
        });
    }
    /**
     * Listen to changes on the store.
     * @param cb
     * @returns A promise resolving to a function to unlisten to the event.
     */
    async onChange(cb) {
        return await listen("store://change", (event) => {
            if (event.payload.path === this.path) {
                cb(event.payload.key, event.payload.value);
            }
        });
    }
}

export { Store };
//# sourceMappingURL=index.min.js.map
